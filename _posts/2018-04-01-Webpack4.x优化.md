---
layout:     post
title:      Webpack4.x打包技巧分享
subtitle:   "烹饪"你的代码
date:       2018-10-21
author:     CNJ
header-img: img/post-bg-vue-web.jpg
catalog: true
tags:
    - 开发技巧
    - Vue
---
* TOC
{:toc}

# Webpack基础配置
---
基本配置
```javascript
  entry 
  默认值是 ./src/ 入口起点
  output.path 
  默认值是 ./dist 配置创建打包文件的地址和名称 
  loader 
  处理非JavaScript文件的加载器，将所有非JavaScript文件转化为有效的”模块“
  plugins 
  loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。
  mode
  模式 用于区分是开发模块还是生产模式

```
例子
```JavaScript

const path = require('path'); 
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 用于访问内置插件
  module.exports = {
    mode: 'production',
    entry: './path/to/my/entry/file.js',  // 分割模块的打包开始文件
    output: {
      path: path.resolve(__dirname, 'dist'), // 该入口下打包文件放置路径
      filename: 'my-first-webpack.bundle.js' // 指定生成的编译文件名字
    },
    module: {  // 对一个单独的module定义rules属性（test和use，例子中校验所有的txt文件用raw-loader加载器去编译，其他如saas，less等都有各自不同的加载器）
      rules: [
        { test: /\.txt$/, use: 'raw-loader' }
      ]
    },
    plugins: [
      new HtmlWebpackPlugin({template: './src/index.html'}) // 处理压缩html文件
    ]
  };
```

多入口分离写法
```Javascript
const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};

```
这是什么？我们告诉 webpack 需要 3 个独立分离的依赖图（如上面的示例）。

为什么？在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：

使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。






模块类型
```
json: 可通过 require 和 import 导入的 JSON 格式的数据(默认为 .json 的文件)
webassembly: WebAssembly 模块，（目前是 .wasm 文件的默认类型）
javascript/auto: (webpack 3中的默认类型)支持所有的JS模块系统：CommonJS、AMD。
javascript/esm: EcmaScript模块（默认 .mjs 文件）。
javascript/dynamic: 仅支持 CommonJS & AMD。
```

例如
```javascript
  props: ['oneExample']

```
```html
  <template>
    <child :one-example = "data"></child>
  </template>
```
***Props传值时，如果使用的是驼峰式命名，父组件传值时必须使用 - 隔开，否则无法准确识别传递对象，因为浏览器不能正确识别大小写，所以会统一换成小写。***

Props可以捕捉父组件的值变化，并且实时更新到子组件中。同时可以限定传值的类型以及Props的默认值等。
例如
```javascript
  props: {
    oneExample: {
      type: 'Number', //限定类型有Number、Boolean、String、Array、Object
      default: 2,
      required: true // 是否必要项
      validator: function (value) {
        // 校验Props值方法，value代表父组件传进的值
    }
  }
``` 


# 双向通信
---
Props属性值传递是单向的，通过子组件更改了Props的值并不会影响到父组件，这是为了让数据流转更为清晰，因为没法定位组件数值变化是由哪一边引起的，造成排查的困难。
但是，如果一定需要更改父组件的值，可以有一下三种方法进行更改。

## 1、$emit

$emit可以触发当前实例上事件，只针对同一个事件名进行调用，用法如下：
```javascript
    this.$emit('on-change', value1, value2...) // value1、value2分别是回调函数会引用的值
```
```html
  <template>
    <div id="app">
        <child v-on:on-change="change"></child>
    </div>
  </template>
```
```javascript
    new Vue ({
      el: 'app',
      methods: {
        change: function(val1,val2...) { // 参数与子组件的传递值顺序一致。
          doSomething
        }
      }
    })
```
此方法可以直接使用props的值进行回调，但是Vue会报警告错误，建议使用组件自身的data值进行$emit的值传递，可以通过watch进行监听Props值的变化并赋值给子组件本身data。
```javascript
    new Vue ({
      el: 'app',
      props:['test'],
      data (): {
        return {
          testData: null
        }
      },
      watch: {
        test: function(newVal, oldVal) {
          this.testData = newVal
        }
      }
      methods: {
        change: function() { // 参数与子组件的传递值顺序一致。
          this.$emit('on-change', this.testData)
        }
      }
    })
```

## 2、.sync修饰符

经历过Vue的多次改版，在2.3.0+后的版本重新加入了.sync修饰符号。
Vue中建议以`update: propName`的模式触发事件并且更新父子组件的值。
```javascript
  this.$emit('update: propNaem', newValue)
```
具体可以写作：
```html
<div v-bing:propName="name" 
     v-on:update:propName="name=$event"></div>
```
以上模式可用.sync修饰符进行简化
```html
<div v-bing:propName.sync="name">
```

## 3、利用内存空间指向进行双向传值

利用JavaScript数据存储原理，利用数组和对象两种引用类型数据格式进行值传递，因为引用类型指向同一片内存空间，所以能够实现组件之间值的双向传递，但是会造成一些可能出现的问题，例如子组件的值改变造成父组件的值进行错误设置等等，慎用。

